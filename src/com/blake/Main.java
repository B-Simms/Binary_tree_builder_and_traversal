// Blake Simmons
// November 7, 2018
// Binary Tree Builder and Traversal

package com.blake;

import java.util.Stack;


// This is a program which, when provided with a postfix expression of single digit integers
// and basic operators (+, -, *, /) creates a corresponding binary tree using a Node Stack.
// The program then performs pre-order, in-order and post-order traversals of the tree and
// displays the expressions generated by those traversals.
public class Main {

    public static void main(String[] args) {

        // declare char array to store postfix expression
        char[] postfix;

        // Create and display postfix expression
        postfix = new char[]{'1', '5', '+', '3', '8', '*', '1', '*', '7', '/', '-', '3', '+'};
        System.out.print("Original postfix expression: [ " );
        for(int i = 0 ; i < postfix.length ; i++){
            System.out.print(postfix[i] + " ");
        }
        System.out.println(" ]\n");


        // Build the tree using a Node Stack based on postfix expression
        Stack<Node> stack = buildTree(postfix);


        // Perform pre-order traversal on the tree and print
        // Method receives "root" node as an argument (stack.peek())
        System.out.print("Pre-Order Traversal: [ ");
        preOrderTraverse(stack.peek());
        System.out.println(" ]");

        // Perform in-order traversal on the tree and print
        System.out.print("In-Order Traversal: [ ");
        inOrderTraverse(stack.peek());
        System.out.println(" ]");

        // Perform post-order traversal on the tree and print
        System.out.print("Post-Order Traversal: [ ");
        postOrderTraverse(stack.peek());
        System.out.println(" ]");


    }

    // This method parses the postfix expression and creates the corresponding binary tree
    public static Stack<Node> buildTree(char[] postfix){

        // Node Stack is created
        Stack<Node> stack = new Stack<Node>();


        for(int i = 0; i < postfix.length ; i++){

            // A new node is created for each element of the postfix expression
            Node node = new Node(postfix[i]);

            // If the value of this node is a digit it is pushed to the stack
            if(Character.isDigit(postfix[i])){
                stack.push(node);

            // Otherwise, the value is an operand and the last two values pushed to
            // the stack are assigned to its right and left nodes.
            // This node is then pushed to the stack itself.
            }else{
                node.right = stack.pop();
                node.left = stack.pop();
                stack.push(node);

            }
        }

        // Once the array has been exhausted, the tree has been properly created
        // and is returned.
        return stack;
    }

    // This method performs the pre-order traversal
    public static void preOrderTraverse(Node node){

        // Create a root within the method and assign it the node
        // received by the method
        Node root = node;

        // Print the value at the node before visiting children
        System.out.print(root.value + " ");

        // If the node's left branch contains a child
        // continue recursively
        if(root.left != null) {
            preOrderTraverse(root.left);
        }

        // If the node's right branch contains a child
        // continue recursively
        if(root.right != null){
            preOrderTraverse(root.right);
        }
    }

    // This method performs the in-order traversal
    public static void inOrderTraverse(Node node){

        // Create a root within the method and assign it the node
        // received by the method
        Node root = node;

        // If the node's left branch contains child
        // continue recursively
        if(root.left != null) {
            inOrderTraverse(root.left);
        }

        // Print the value at the node in between visiting children
        System.out.print(root.value + " ");

        // If the node's right branch contains a child
        // continue recursively
        if(root.right != null){
            inOrderTraverse(root.right);
        }
    }

    // This method performs the post-order traversal
    public static void postOrderTraverse(Node node){

        // Create a root within the method and assign it the node
        // received by the method
        Node root = node;

        // If the node's left branch contains another node
        // continue recursively
        if(root.left != null) {
            postOrderTraverse(root.left);
        }

        // If the node's right branch contains a child
        // continue recursively
        if(root.right != null){
            postOrderTraverse(root.right);
        }

        // Print the value at the node last
        System.out.print(root.value + " ");
    }

    // This is the Node class
    public static class Node {

        // store value of node and reference to child nodes
        char value;
        Node left;
        Node right;

        // Constructor receives and assigns the node value and
        // defaults the children to null
        Node(char value) {
            this.value = value;
            left = right = null;
        }
    }

}
